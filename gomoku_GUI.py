import turtle

class Visuals:
    BOARDSIZE = 630 #Board size, in pixels.
    OFFSETX = -200
    OFFSETY = -290

    #> Sets up the space within which the game is played and assigns key bindings.
    #> Registers shapes, such as the background image and game pieces.
    #> Sets up all necessary turtles.
    def __init__(self):
        # Initializes the window space.
        self.win = turtle.Screen()
        self.win.title("GOMOKU")
        # Resizes and centers the Turtle window.
        self.win.setup(width=910,height=710)


        # Sets up images for use elsewhere
        images = turtle.getscreen()
        images.bgpic("background.gif")
        images.register_shape("welcomeScreen.gif")
        images.register_shape("helpScreen.gif")
        images.register_shape("winMessage.gif")
        images.register_shape("loseMessage.gif")
        images.register_shape("diffSettings.gif")
        images.register_shape("diffWarning.gif")
        images.register_shape("noDiffDisplay.gif")
        images.register_shape("easyDiffDisplay.gif")
        images.register_shape("medDiffDisplay.gif")
        images.register_shape("hardDiffDisplay.gif")

        # Bugfix to hide the "anonymous" turtle generated by the registered shapes.
        turtle.getturtle().hideturtle()

        # Sets all the turtles for play
        self.turtleBreeder()


    #> Sets up all of the necessary Turtle widow bindings required to process:
    #  click input (gameplay and buttons),
    #  keyboard shortcuts (exit, save, load, difficulty, help, welcome)
    def setupBindings(self):
        self.win.onclick(self.game.sectionSelector)
        self.win.onkey(self.game.initializeNewGame,"n")
        self.win.onkey(exit,"e")
        self.win.onkey(exit,"x") #>Since "x" is so much more "exit" than "e".
        self.win.onkey(self.game.saveGame,"s")
        self.win.onkey(self.game.loadGame,"l")
        self.win.onkey(self.toggleWelcome,"w")
        self.win.onkey(self.toggleDiffSettings,"d")
        self.win.onkey(self.disableComp,"0")
        self.win.onkey(self.toggleHelp,"h")
        self.win.listen()


    #> Draws the Gomoku board grid and labels each line.
    #> Uses self.lineman, which must already have been initialized.
    def drawBoard(self):
        # Sets the animation tracing to an instantaneous mode.
        self.win.tracer(2)

        # Draws horizontal lines.
        # Offsets the starting position to give the board "spokes".
        gotox = -self.game.cellSize/2 + self.OFFSETX
        gotoy = 0 + self.OFFSETY
        self.lineman.setheading(0)
        for row in range(1,self.game.dimension+1):
            self.lineman.penup()
            self.lineman.goto(gotox, gotoy)
            self.lineman.pendown()
            self.lineman.write(row,move=False,align="left",font=("Arial",10,"normal"))
            self.lineman.forward(self.BOARDSIZE)
            self.lineman.write(row,move=False,align="right",font=("Arial",10,"normal"))
            gotoy = gotoy + self.game.cellSize #Offsets the y-coord by a grid unit.

        # Constructs a list containing 'n' capital letters, where n = dimension.
        upperCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        letters = []
        for let in range(self.game.dimension):
            letters.append(upperCase[let])

        # Draws vertical lines.
        gotox = 0 + self.OFFSETX
        gotoy = -self.game.cellSize/2 + self.OFFSETY
        self.lineman.setheading(90)
        for col in letters:
            self.lineman.penup()
            self.lineman.goto(gotox, gotoy-25)
            self.lineman.write(col,move=False,align="center",font=("Arial",10,"normal"))
            self.lineman.forward(25)
            self.lineman.pendown()
            self.lineman.forward(self.BOARDSIZE)
            gotox = gotox + self.game.cellSize #Offsets the x-coord by a grid unit.
            self.lineman.write(col,move=False,align="center",font=("Arial",10,"normal"))

        # Sets the animation tracing back to normal
        self.win.tracer(1)


    #> Creates instance-wide turtles to enable so that their stamps
    #  can be cleared later, which is not possible if they are local.
    def turtleBreeder(self):
        # Initializes the turtle which will write the turn number.
        self.turner = turtle.Turtle()
        self.turner.hideturtle()
        self.turner.color("indigo")
        self.turner.penup()
        self.turner.speed(0)
        self.turner.goto(-150+self.OFFSETX,340+self.OFFSETY)

        # Initializes the turtle used to stamp game pieces.
        self.stamper = turtle.Turtle()
        self.stamper.hideturtle()
        self.stamper.shape("circle")
        self.stamper.speed(0)
        self.stamper.penup()
        self.stamper.goto(50+self.OFFSETX,50+self.OFFSETY)

        # Initializes the turtle which draws the grid.
        self.lineman = turtle.Turtle()
        self.lineman.hideturtle()
        self.lineman.color("white")
        self.lineman.width(2)

        # Initializes the turtle which writes messages in the game window.
        self.messenger = turtle.Turtle()
        self.messenger.hideturtle()
        self.messenger.color("white")
        self.messenger.speed(0)
        self.messenger.penup()
        self.messenger.goto(-245+self.OFFSETX, 185+self.OFFSETY)

        # Initializes the turtle which will draw the "win line".
        self.winMan = turtle.Turtle()
        self.winMan.hideturtle()
        self.winMan.color("red")
        self.winMan.width(5)
        self.winMan.speed(0)
        self.winMan.penup()

        # Initializes the turtle which will display the difficulty level.
        self.diffDisplayer = turtle.Turtle()
        self.diffDisplayer.shape("easyDiffDisplay.gif") #Default difficulty

        # Initializes the turtle which will display a warning message.
        self.diffWarner = turtle.Turtle()
        self.diffWarner.hideturtle()
        self.diffWarner.shape("diffWarning.gif")

        # Initializes the turtle which will allow user to select difficulty.
        self.diffSetter = turtle.Turtle()
        self.diffSetter.hideturtle()
        self.diffSetter.shape("diffSettings.gif")

        # Sets up the turtle which displays the intro screen.
        self.welcomeMan = turtle.Turtle()
        self.welcomeMan.hideturtle()
        self.welcomeMan.shape("welcomeScreen.gif")

        # Sets up the turtle which displays the help screen.
        self.helpMan = turtle.Turtle()
        self.helpMan.hideturtle()
        self.helpMan.shape("helpScreen.gif")

        # Sets up the turtle which displays the win/lose image.
        self.resultMan = turtle.Turtle()
        self.resultMan.hideturtle()


    #> Toggles the welcome screen image. Initial value of game.welcome is "None"
    #  so that boolean logic can be used.
    #>> This enables toggling using key input, which cannot pass parameters.
    def toggleWelcome(self):
        if self.game.welcomeVisible:
            self.welcomeMan.clear()
            self.game.welcomeVisible = False
        else:
            self.welcomeMan.stamp()
            self.game.welcomeVisible = True


    #> Toggles the help screen image. Works identically to toggleWelcome(),
    #  except that the initial value of game.help is False, since it shouldn't
    #  display by default.
    def toggleHelp(self):
        if self.game.helpVisible:
            self.helpMan.clear()
            self.game.helpVisible = False
        else:
            self.helpMan.stamp()
            self.game.helpVisible = True


    #> Writes the number of turns a player has taken to the message board.
    def displayTurn(self):
        self.turner.clear()
        self.turner.write(self.game.move, move=False,\
                          align="left", font=("Helvetica", 35, "normal"))

    
    #> Uses the click x value to determine whether the confirm or cancel buttons
    #  has been clicked. If the xPos is <-165, then the confirm code is executed;
    #  the new difficulty is set and a new game is begun.
    def diffConfirmation(self, xPos):
        self.displayMessage("clear")
        self.diffWarner.hideturtle()
        self.game.diffWarnVisible = False

        if xPos < -165:
            self.game.diff = self.game.newDiff
            self.displayDiff()
            self.game.initializeNewGame()


    #> Stamps the image for the current difficulty level in the message box
    def displayDiff(self):
        if self.game.diff == 0: # No AI mode; easter egg / debugging
            self.diffDisplayer.shape("noDiffDisplay.gif")
        elif self.game.diff == 1:
            self.diffDisplayer.shape("easyDiffDisplay.gif")
        elif self.game.diff == 2:
            self.diffDisplayer.shape("medDiffDisplay.gif")
        elif self.game.diff == 3:
            self.diffDisplayer.shape("hardDiffDisplay.gif")

            
    #> Toggles the "difficulty change warning" which tells the user that their
    #  current game progress will be lost, and seeks confirmation.
    #> The "set difficulty" prompt is always hidden when this is run.
    #> If the selected difficulty is already set, an error is displayed
    def toggleDiffWarning(self):
        self.diffSetter.hideturtle()
        self.game.diffSetVisible = False

        if self.game.diffWarnVisible:
            self.diffWarner.hideturtle()
            self.game.diffWarnVisible = False

        elif self.game.newDiff != self.game.diff:
            self.displayMessage("clear")
            self.diffWarner.showturtle()
            self.game.diffWarnVisible = True

        else:
            self.displayMessage("That  difficulty\n  setting  was\n  already  set!")

            
    #> Toggles the "set difficulty" prompt, which enables the user to choose
    #  the difficulty of the next game they play. 
    def toggleDiffSettings(self):
        if self.game.diffSetVisible:
            self.diffSetter.hideturtle()
            self.game.diffSetVisible = False
        else:
            self.displayMessage("clear")
            self.diffSetter.showturtle()
            self.game.diffSetVisible = True
    
   
    #> This function manages the "easter egg" / debugging functionality of
    #  disabling the AI so that the computer does not make any moves. 
    #> The only way that this function is invoked is through the keyboard bindings
    #  assigned to the "0" numerical key.
    def disableComp(self):
        if self.game.diff != 0:
            self.game.diff = 0
        else:
            self.game.diff = 2
        self.displayDiff()
        
        
    #> Accepts a string and writes it to the display area left of the game board.
    #> Used to display arbitrary information to the user.
    def displayMessage(self, message):
        # Clears anything that could be in the message box.
        self.messenger.clear()
        if self.game.diffSetVisible:
            self.toggleDiffSettings()
        elif self.game.diffWarnVisible:
            self.toggleDiffWarning()
        elif self.game.winState:
            self.resultMan.clear()

        if message != "clear":
            self.messenger.write(message, move=False, \
                                 align="left", font=("Impact", 22, "normal"))


    #> Stamps the current player's game piece at the X and Y coordinates specified
    def stampPiece(self, posX,posY):
        if self.game.player == "B":
            self.stamper.color("black")
        else:
            self.stamper.color("white")
        self.stamper.shapesize(2*(10/self.game.dimension),2*(10/self.game.dimension))
        self.stamper.goto(posX+self.OFFSETX,posY+self.OFFSETY)
        self.stamper.stamp()


    #> Draws a line which passes through the 5 winning pieces, and prints a message.
    #> Both parameters are expected to be numerical 2-tuples of form (col, row).
    def setWin(self, start, end):
        self.game.winState = True

        if self.game.player == self.game.human:
            self.resultMan.shape("winMessage.gif")
            self.resultMan.stamp()
        else:
            self.resultMan.shape("loseMessage.gif")
            self.resultMan.stamp()

        #> Finds coordinates for start and endpoint of winning play
        # using tuples passed as parameters
        xStart = start[0] * self.game.cellSize + self.OFFSETX
        yStart = start[1] * self.game.cellSize + self.OFFSETY
        xEnd = end[0] * self.game.cellSize + self.OFFSETX
        yEnd = end[1] * self.game.cellSize + self.OFFSETY

        #> Draws the win line
        self.winMan.goto(xStart,yStart)
        self.winMan.speed(1)
        self.winMan.pendown()
        self.winMan.goto(xEnd,yEnd)
        self.winMan.penup()